.PHONY: clean
.PHONY: test
.PHONY: lib

# unity test framework source folder
PATHU := ../unity/src/
# project source folder(s) (space separated)
PATHS := ./src/ ../iterator/
# project test source folder
PATHT := ./test/

# build locations
PATHB := ./build/
PATHO := ./build/objs/
PATHR := ./build/results/
BUILD_PATHS = $(PATHB) $(PATHO) $(PATHR)

# generate a list of all source files
SRCS = $(foreach dir,$(PATHS),$(wildcard $(dir)*.c))
# generate a list of all test files
SRCT = $(wildcard $(PATHT)*.c)

# config
CLEANUP := rm -f
MKDIR := mkdir -p
TARGET_EXTENSION := out

CC := gcc -c
LINK := gcc
LDLIBS := -lgc
CFLAGS := -Wall -g # debug

# generate a list of includes
INCLUDES = $(foreach dir,$(PATHS),-I$(dir))

# generate a list of object files from the project source files
OBJS = $(foreach file,$(notdir $(SRCS)),$(patsubst %.c,$(PATHO)%.o,$(file)))

# generate a list of dependency files from the source files
DEPS = $(foreach file,$(notdir $(SRCS)),$(patsubst %.c,$(PATHO)%.d,$(file)))

# generate a list of object files from the test source files
OBJT = $(foreach file,$(notdir $(SRCT)),$(patsubst %.c,$(PATHO)%.o,$(file)))

# test results are generated by running the executable
RESULTS := $(patsubst $(PATHT)test_%.c,$(PATHR)test_%.txt,$(SRCT))

# the results are parsed into variables using grep
PASSED := `grep -s PASS $(PATHR)*.txt`
FAIL := `grep -s FAIL $(PATHR)*.txt`
IGNORE := `grep -s IGNORE $(PATHR)*.txt`

# default is to build and run the tests
all: test

# just build the library without the tests
lib: $(BUILD_PATHS) $(OBJS) $(DEPS)

# 'test' target depends on the build directories and the results file existing
# command just pretty-prints the results
test: $(BUILD_PATHS) $(RESULTS) $(DEPS)
	@echo "-----------------------\nIGNORES:\n-----------------------"
	@echo "$(IGNORE)"
	@echo "-----------------------\nFAILURES:\n-----------------------"
	@echo "$(FAIL)"
	@echo "-----------------------\nPASSED:\n-----------------------"
	@echo "$(PASSED)"
	@echo "\nDONE"

# the test results file depends on running the compiled executable
$(PATHR)test_%.txt: $(PATHB)test_%.$(TARGET_EXTENSION)
	-./$< > $@ 2>&1

# the compiled test executable depends on the compiled object files
$(PATHB)%.$(TARGET_EXTENSION): $(OBJS) $(OBJT) $(PATHO)unity.o
	$(LINK) -o $@ $^ $(LDLIBS)

# the unity object file depends on the unity c & h files
$(PATHO)unity.o: $(PATHU)unity.c $(PATHU)unity.h
	$(CC) $(CFLAGS) -I$(PATHU) $< -o $@

# the test object files depend on the test c files
$(PATHO)test_%.o:: $(PATHT)test_%.c
	$(CC) $(CFLAGS) $(INCLUDES) -I./$(PATHT) $< -o $@

# the build directories are created if they don't exist
$(PATHB):
	$(MKDIR) $(PATHB)

$(PATHO):
	$(MKDIR) $(PATHO)

$(PATHR):
	$(MKDIR) $(PATHR)

# dummy target cleans up the build files
clean:
	$(CLEANUP) $(PATHO)*.o
	$(CLEANUP) $(PATHO)*.d
	$(CLEANUP) $(PATHB)*.$(TARGET_EXTENSION)
	$(CLEANUP) $(PATHR)*.txt

# retain files until they are cleaned manually
.PRECIOUS: $(PATHB)%.$(TARGET_EXTENSION)
.PRECIOUS: $(PATHO)%.o
.PRECIOUS: $(PATHR)%.txt
.PRECIOUS: $(PATHO)test_%.o

# this section is needed because make is too stupid
# to be able to generate object files from source
# files given an arbitray set of directories
#
# eval dynamically generates rules for object files
# files where each object file depends on the c src
# file. standard make rules need the source dir
# to be explicitly coded into the rules. d'oh
#
# the generated rules look like this
#
# build/objs/file.o: path/to/c/file.c
# 	$(CC) $(CFLAGS) path/to/c/file.c -o build/objs/file.o
#
#
# use this function to generate a pattern rule for %.c -> %.o
define obj_from_src
$(info generating rule: $(1): $(2))
$(1): $(2)
	$(CC) $(CFLAGS) $(INCLUDES) $(2) -o $(1)

endef

# use this function to generate a pattern rule for %.c -> %.d
define dep_from_src
$(info generating rule: $(1): $(2))
$(1): $(2)
	$(CC) -E -MP -MMD -MF $(1) $(2) > /dev/null

endef
#
#
# for each source file call the function with parameters of the obj file and source file
# the location of the obj files is generate from the source name by pattern substution
$(eval $(foreach C,$(SRCS),$(call obj_from_src,$(patsubst %,$(PATHO)%.o,$(basename $(notdir $(C)))),$(C))))

# same for dependencies
$(eval $(foreach C,$(SRCS),$(call dep_from_src,$(patsubst %,$(PATHO)%.d,$(basename $(notdir $(C)))),$(C))))
#
# include generated dependencies so that make will rebuild if a header changes
-include $(DEPS)
